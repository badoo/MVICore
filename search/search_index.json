{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MVICore","text":""},{"location":"#whats-this","title":"What's this?","text":"<p>MVICore is a modern, Kotlin-based MVI framework:</p> <ul> <li>Scaling with complexity: operate with a single Reducer if needed, with the option of having the full power of additional components to handle more complex cases</li> <li>Event handling: A solution to handling events that you don\u2019t want to store in the state</li> <li>Reactive component binding: A super simple API to bind your reactive endpoints to each other with automatic lifecycle handling</li> <li>Custom Middlewares: for every single component in the system, with flexible configuration options</li> <li>Logger: An out-of-the-box logger Middleware</li> <li>Time Travel Debugger: for ALL of your reactive components (not just your state machine!) with UI controls for recording and playback</li> </ul>"},{"location":"#the-big-picture","title":"The big picture","text":""},{"location":"#1-create-your-state-machine","title":"1. Create your state machine","text":"<pre><code>class SimpleFeature : ReducerFeature&lt;Wish, State, Nothing&gt;(\n    initialState = State(),\n    reducer = ReducerImpl()\n) {\n    // Define your immutable state as a Kotlin data class\n    data class State(\n        val counter: Int = 0\n    )\n\n    // Define the ways it could be affected\n    sealed class Wish {\n        object IncreaseCounter : Wish()\n        data class MultiplyBy(val value: Int) : Wish()\n    }\n\n    // Define your reducer\n    class ReducerImpl : Reducer&lt;State, Wish&gt; {\n        override fun invoke(state: State, wish: Wish): State =\n\n            // Leverage the power of exhaustive when over Kotlin sealed classes\n            when (wish) {\n\n                // Create the next state based on the current one\n                IncreaseCounter -&gt; state.copy(\n                    counter = state.counter + 1\n                )\n\n                // Create the next state based on the current one\n                is MultiplyBy -&gt; state.copy(\n                    counter = state.counter * wish.value\n                )\n            }\n    }\n}\n</code></pre> <p>Note</p> <p><code>Feature</code> has additional components to solve problems like side-effects, events, initialisation, internal jobs in a standardised way. For a full list check Features section to see what's possible.</p>"},{"location":"#2-your-state-machine-is-reactive","title":"2. Your state machine is reactive","text":"<pre><code>val feature = SimpleFeature()\n\n// Now you can observe and subscribe to its state changes:\nObservable.wrap(feature).subscribe { state -&gt; TODO() }\n\n// And it's also a Consumer of Wishes. Trigger some state changes:\nObservable.just(Wish.IncreaseCounter).subscribe(feature)\n</code></pre> <p>Actually, don't use it the above way! We can do so much better:</p>"},{"location":"#3-use-the-binder","title":"3. Use the Binder","text":"<p>For connecting your reactive components. Comes with automatic lifecycle handling and invoking transformations:</p> <pre><code>val binder = Binder(lifecycle)\nbinder.bind(view to feature using ViewEventToWish)\nbinder.bind(feature to view using StateToViewModel)\n</code></pre>"},{"location":"#download","title":"Download","text":"<p>Available through jitpack.</p> <p>Add the maven repo to your root <code>build.gradle</code></p> <pre><code>allprojects {\n    repositories {\n        maven { url 'https://jitpack.io' }\n    }\n}\n</code></pre> <p>Add the dependencies:</p> <ul> <li> <p>Framework: <pre><code>implementation 'com.github.badoo.mvicore:mvicore:{latest-version}'\n</code></pre></p> </li> <li> <p>Helper classes for Android: <pre><code>implementation 'com.github.badoo.mvicore:mvicore-android:{latest-version}'\n</code></pre></p> </li> <li> <p>ModelWatcher for efficient view updates <pre><code>implementation 'com.github.badoo.mvicore:mvicore-diff:{latest-version}'\n</code></pre></p> </li> <li> <p>Time Travel Debugger controls in a DebugDrawer module (You need to add the dependencies to DebugDrawer and configure it yourself before you can use this): <pre><code>implementation 'com.github.badoo.mvicore:mvicore-debugdrawer:{latest-version}'\n</code></pre></p> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#pending-changes","title":"Pending changes","text":"<p>(#195): Updated Kotlin to 1.9.23</p> <p>(#193): Updated Kotlin to 1.8.10</p>"},{"location":"changelog/#140","title":"1.4.0","text":""},{"location":"changelog/#additions","title":"Additions","text":"<p>(#179): Introduced the ability to specify observation scheduler within the <code>Binder</code> class (see the <code>observeOn</code> DSL below), as well as the <code>observeOn</code> infix operator for <code>Connection</code> class (related to <code>Binder</code>).</p> <p>An example of how you might use this is as follows:</p> <pre><code>// mvicore-android example\ntestLifecycleOwner.lifecycle.createDestroy {\n    observeOn(mainScheduler) {\n        bind(events to uiConsumer1)\n        bind(events to uiConsumer2)\n    }\n    observeOn(backgroundScheduler) {\n        bind(events to backgroundConsumer1)\n        bind(events to backgroundConsumer2)\n    }\n    bind(events to uiConsumer3 observeOn mainScheduler)\n    bind(events to backgroundConsumer3 observeOn backgroundScheduler)\n}\n\n// binder example\nbinder.observeOn(mainScheduler) {\n    bind(events to uiConsumer1)\n    bind(events to uiConsumer2)\n}\n</code></pre> <p>See more details in advanced binder section.</p> <p>(#177): Updated AndroidX appcompat to 1.4.1 and lifecycle to 2.5.1. Also updated Compile and Target SDK to API 33.</p> <p>(#176): Updated RxJava to 2.2.21 and RxKotlin to 2.4.0</p> <p>(#173): Updated Kotlin to 1.7.10</p> <p>(#162): Updated Kotlin to 1.6.21 (the plan is to update to 1.7.x fairly soon)</p>"},{"location":"changelog/#131","title":"1.3.1","text":""},{"location":"changelog/#bug-fixes","title":"Bug fixes","text":"<p>(#138): Fixed regression related to BaseFeature actor.</p> <p>The Actor subject was made serializable, and was also using a flatMap. Both of these changes caused a change in behaviour relating to the ordering of news (in features that have a PostProcessor which triggers extra actions). This change was made as part of introducing the optional <code>FeatureScheduler</code> to <code>BaseFeature</code>.</p> <p>If you provide a <code>FeatureScheduler</code> and use a PostProcessor, please be aware that the ordering of your news could change.</p> <p>The previous news ordering behaviour is actually a bug in BaseFeature caused by recursion, and will hopefully be addressed (as an opt in change) in a future release.</p>"},{"location":"changelog/#130","title":"1.3.0","text":""},{"location":"changelog/#additions_1","title":"Additions","text":"<p>(#147): Introduced 'async' feature which is moves work to a dedicated single-threaded <code>feature scheduler</code>, while being observable on the <code>observation scheduler</code></p> <p>(#148): Updated mockito-kotlin library.</p> <p>(#150): Fixed Bootstrapper variance.</p> <p>(#150): Minor improvements to the new 'async' feature.</p> <p>(#158): Introduced an optional <code>FeatureScheduler</code> which can be used with non-async features. This is useful when a feature is instantiated on a thread other than the thread it should be bound to (for example the UI thread).</p> <p>When providing a <code>FeatureScheduler</code>, the feature is able to correctly switch to its desired thread rather than throwing an exception.</p> <p>(#160): Changed to Java 8 compatibility</p> <p>(#161): Improved the error message thrown by <code>SameThreadVerifier</code>. It now includes the feature's class name and the thread names.</p>"},{"location":"changelog/#126","title":"1.2.6","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug fixes","text":"<p>(#138): Generated templates plugin to be able to work on AndroidStudio 4.1. Fixes (#135).</p>"},{"location":"changelog/#125","title":"1.2.5","text":""},{"location":"changelog/#api-changes","title":"API changes","text":"<p>(#134): Migrated project to AndroidX.</p> <p>(#129): Extracted binder from mvicore module. To continue using it, please add this additional dependancy: <code>com.github.badoo.mvicore:binder:x.x.x</code>.</p>"},{"location":"changelog/#124","title":"1.2.4","text":""},{"location":"changelog/#api-changes_1","title":"API changes","text":"<p>(#112): Update model watcher dsl to support sealed classes.</p>"},{"location":"changelog/#additions_2","title":"Additions","text":"<p>(#113): Updated inspector plugin Android Studio version to 2019.2.</p>"},{"location":"changelog/#123","title":"1.2.3","text":""},{"location":"changelog/#additions_3","title":"Additions","text":"<p>(#106): Improve type signatures for <code>ModelWatcher</code>. This does not impact the existing API.</p>"},{"location":"changelog/#122","title":"1.2.2","text":""},{"location":"changelog/#dependency-changes","title":"Dependency changes","text":"<p>(#102): Changed the gradle artifact group id from <code>com.github.badoo</code> to <code>com.github.badoo.mvicore</code> Ensure that you update your gradle build files (i.e. <code>com.github.badoo.mvicore:binder:x.x.x</code>)</p>"},{"location":"changelog/#121","title":"1.2.1","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug fixes","text":"<p>(#98): Fix issues with inspector plugin</p> <p>(#100): Fix 1.2.0 debug drawer build</p>"},{"location":"changelog/#120","title":"1.2.0","text":""},{"location":"changelog/#api-changes_2","title":"API changes","text":"<p>(#66): <code>Connection</code> is updated to provide information about both <code>ObservableSource</code> and <code>Consumer</code> types. <code>ConsumerMiddleware&lt;In&gt;</code> is replaced by <code>Middleware&lt;Out, In&gt;</code> to provide access to both input and output types of the <code>Connection</code>.</p>"},{"location":"changelog/#additions_4","title":"Additions","text":"<p>(#73): Allows transformer to access to the stream between <code>Source</code> and <code>Consumer</code>. See more details in  advanced binder section.</p> <p>(#76): <code>MemoFeature</code> which keeps latest accepted state.</p> <p>(#82): Organized way of diffing fields in model to provide more efficient view updates. More information here.</p> <p>(#77): Idea plugin to observe elements of connections based on middlewares. Read about it here.</p>"},{"location":"demoproject/","title":"Example app","text":""},{"location":"demoproject/#example-app","title":"Example app","text":"<p>You can check out the <code>mvicore-demo-app</code> module and deploy it to your Android device to see some of the possibilities of MVICore applied in practice.</p> <p> </p> <p>Points of interest:</p> <ul> <li><code>Feature1</code>: Simple state machine holding on to state of coloured buttons and counter</li> <li><code>Feature2</code>: Asynchronous state machine responsible for loading images from the The Cat API</li> <li><code>MainActivityBindings</code>: Showcasing <code>Binder</code> usage, combining the state of <code>Feature1</code> + <code>Feature2</code> and translating them to a <code>ViewModel</code> to the screen, also connecting the UI to the Features</li> <li><code>App.kt</code> for Middleware configurations</li> <li>Dagger configuration to make <code>Feature1</code> and <code>Feature2</code> live longer than the Activity, but lose their state on \"sign out / sign in\" cycle</li> <li>Check out the DebugDrawer module (swipeable from the right side of the screen) for Time Travel Debugger controls.</li> </ul>"},{"location":"externallinks/","title":"External links","text":""},{"location":"externallinks/#related-articles-videos","title":"Related articles &amp; videos","text":"<ul> <li>MVI beyond state reducers</li> <li>Building a system of reactive components with Kotlin</li> <li>Unidirectional data-flow and the Zen of black box components</li> <li>Time Travel Debug Everything!</li> </ul>"},{"location":"bestpractices/delayingbootstrapping/","title":"Delaying bootstrapping","text":""},{"location":"bestpractices/delayingbootstrapping/#bootstrapping-is-immediate-by-default","title":"Bootstrapping is immediate by default","text":"<p>As noted in the core concepts section, <code>Features</code> are essentially hot observables. It's worth to repeat this here, because there's an important aspect of it here: <code>Bootstrapper</code> is invoked immediately on <code>Feature</code> creation and by default will not wait for anything else.</p> <p>You can picture the <code>Feature</code> as if it was a glorified <code>BehaviourSubject</code>: when you create that with <code>createDefault</code>, it emits its first state straight away and continues to emit whatever is put into it after creation.</p>"},{"location":"bestpractices/delayingbootstrapping/#missing-initial-emissions","title":"Missing initial emissions?","text":"<p>Following from this, it is possible that by the time you subscribe to your <code>Feature</code>, the actions triggered by <code>Bootstrapper</code> have already resulted in multiple state updates, and that you can't catch all of them.</p> <p>If you are using your <code>Feature</code> as part of an MVI approach, then the last (current) state of it should always be enough to render the <code>View</code>, so in these cases it shouldn't be an issue at all.</p> <p>But, as you can use a <code>Feature</code> as a more generic tool, in some rare cases it can be valid that you absolutely need to catch and evaluate all state/news emissions.</p>"},{"location":"bestpractices/delayingbootstrapping/#catching-all-emissions","title":"Catching all emissions","text":"<p>In a cross-cutting concern case (e.g. logging) you probably want to go with middlewares. </p> <p>If that's not the case, you might want to delay bootstrapping for whatever reason outside of <code>Feature</code>. </p>"},{"location":"bestpractices/delayingbootstrapping/#dont","title":"Don't","text":"<p>What you don't want to do is create \"Init\" <code>Wish</code> for example. That results in it being a repeatable and public action on the <code>Feature</code> (nothing is stopping you from pushing the same <code>Wish</code> even multiple times from any other part of the code), and is considered a smell.</p>"},{"location":"bestpractices/delayingbootstrapping/#do","title":"Do","text":"<p>Rather, you can achieve the delay by injecting an <code>Observable</code> through the constructor of the <code>Feature</code> to the constructor of your <code>Bootstrapper</code> and use that stream to delay subscription:</p> <pre><code>// Feature\nclass SomeFeature(\n    startSignal: Single&lt;Unit&gt;\n    // ...\n) : BaseFeature&lt;Wish, Action, Effect, State, News&gt;(\n    // ...\n    bootstrapper = BootStrapperImpl(startSignal)\n    // ...\n) {\n    // ...\n\n    class BootStrapperImpl(\n        private val startSignal: Single&lt;Unit&gt;\n    ) : Bootstrapper&lt;Action&gt; {\n        override fun invoke(): Observable&lt;Action&gt; = \n            just(Action.BootstrappingAction)\n                .delaySubscription(startSignal.toObservable())\n\n    // ...\n}\n\n\n// Client code\nval startSignal = PublishRelay.create&lt;Unit&gt;()\nval feature = SomeFeature(startSignal)\n// TODO do stuff, subscribe to feature, etc., and when you are ready:\nstartSignal.accept(Unit)\n</code></pre> <p>This way it's both non-repeatable and it's also not exposed to the public API (<code>Wishes</code>)</p>"},{"location":"bestpractices/dumbreducers/","title":"Keep your Reducers dumb","text":"<p>The idea is that <code>Reducer</code> should contain only resolution to how an <code>Effect</code> modifies the <code>State</code> directly.</p> <pre><code>class ReducerImpl : Reducer&lt;State, Effect&gt; {\n    override fun invoke(state: State, effect: Effect): State = when (effect) {\n        // This is fine:\n        is Effect1 -&gt; state.copy(someFlag = true)\n        is Effect2 -&gt; state.copy(someData = effect.data)\n        is Effect3 -&gt; state.copy(counter = state.counter + 1)\n\n        // Don't do this:\n        is Effect4 -&gt; if (someCondition) (someFlag = true) else state.copy(counter = state.counter + 1)\n    }\n}\n</code></pre> <p>If you find yourself adding conditionals, it's a smell that probably business logic is creeping from your <code>Actor</code> to your <code>Reducer</code>.</p> <p>Resolution: <code>Actor</code> is the intended place for business logic:</p> <ol> <li>Create <code>Effects</code> with meaningful names to describe what can happen to your <code>State</code></li> <li>Decide what happens inside your <code>Actor</code>, based on any conditional logic or async execution, and emit the corresponding <code>Effects</code></li> <li>Use your <code>Reducer</code> only to implement how it modifies the <code>State</code></li> </ol>"},{"location":"bestpractices/effectsinactor/","title":"Effects only in Actor","text":"<p>Once the complexity grows inside your <code>Actor</code>, you might be tempted to extract some responsibilities to other classes.</p> <p>This is fine, however, don't do this:</p> <pre><code>class ActorImpl(\n    private val executor1: Executor1,\n    private val executor2: Executor2\n) : Actor&lt;State, Wish, Effect&gt; {\n\n    override fun invoke(state: State, wish: Wish): Observable&lt;Effect&gt; = when (wish) {\n        is Wish1 -&gt; executor1.doSomething()\n        is Wish2 -&gt; executor2.doSomething()\n    }\n}\n\n// In some other files:\n\nclass Executor1 {\n    fun doSomething(): Observable&lt;Effect&gt; = TODO()\n}\n\nclass Executor2 {\n    fun doSomething(): Observable&lt;Effect&gt; = TODO()\n}\n</code></pre> <p>This way the reader of your code can have no simple understanding of what <code>Effect</code> is the result of what and where.</p> <p>Resolution:</p> <ol> <li>Keep your <code>Effects</code> internal to your <code>Feature</code></li> <li>In your extracted classes use only local result types</li> <li>Map those results to <code>Effects</code> in your <code>Actor</code>, ensuring that all business logic is understandable in a high-level overview in one place.</li> </ol> <p>Example:</p> <pre><code>class ActorImpl(\n    private val executor1: Executor1,\n    private val executor2: Executor2\n) : Actor&lt;State, Wish, Effect&gt; {\n\n    override fun invoke(state: State, wish: Wish): Observable&lt;Effect&gt; = when (wish) {\n        is Wish1 -&gt; executor1\n            .doSomething()\n            .map { when (it) {\n                is SomethingHappened1 -&gt; Effect1(it.data)\n                is SomethingHappened2 -&gt; Effect2\n            }}\n\n        is Wish2 -&gt; executor2\n            .doSomething()\n            .map { when (it) {\n                is SomethingElseHappened1 -&gt; Effect3\n                is SomethingElseHappened2 -&gt; Effect4(it.error)\n            }}\n    }\n}\n\n// In some other files:\n\nclass Executor1 {\n    fun doSomething(): Observable&lt;LocalResult&gt; = TODO()\n\n    sealed class LocalResult {\n        data class SomethingHappened1(val data: Any) : LocalResult()\n        object SomethingHappened2 : LocalResult()\n    }\n}\n\nclass Executor2 {\n    fun doSomething(): Observable&lt;LocalResult&gt; = TODO()\n\n    sealed class LocalResult {\n        object SomethingElseHappened1 : LocalResult()\n        data class SomethingElseHappened2(val error: Throwable) : LocalResult()\n    }\n}\n</code></pre>"},{"location":"bestpractices/efficientviewupdates/","title":"Efficient view updates","text":"<p>If you have complex view models, you probably don't want to re-render the whole UI just because one field has changed. Even though usually it's not a big issue, in extreme cases, this can cause performance problems.</p> <p>MVICore comes with a tool called <code>ModelWatcher</code> that addresses this issue. It allows you to split your view model stream by fields and update only relevant parts of your UI, when those fields have actually changed.</p> <p>See more info in relevant section under extras.</p>"},{"location":"bestpractices/f2f/","title":"Feature to Feature communication","text":""},{"location":"bestpractices/f2f/#dont","title":"Don't","text":"<p>At the initial launch of this library, the suggested way to make two <code>Features</code> communicate with each other was to inject one in the constructor of the other.</p> <p>This was before we elaborated on the <code>Binder</code>, and it's not just no longer suggested, but it's straight out considered an anti-pattern.</p> <p>Injecting them has many disadvantages:</p> <ol> <li>They become coupled</li> <li>Scoping becomes a potential problem (it works only as long the injected one is always supposed to outlive the other one)</li> <li>If you need two-way connection between them, it manifests itself as a circular dependency   </li> </ol>"},{"location":"bestpractices/f2f/#do","title":"Do","text":"<p>Use <code>Binder</code> bindings to connect <code>Features</code> as described in the relevant chapter:</p> <pre><code>binder.bind(feature1.news to feature2 using NewsToWish)\n</code></pre> <p>This is considered superior to the above injection-based approach in all aspects:</p> <ol> <li><code>Features</code> can stay completely decoupled from one another</li> <li>Scoping is automatically handled by <code>Binder</code></li> <li><code>Binder</code> can even resubscribe a connection automatically if needed</li> <li>In the case of a two-way connection, you can do it without a circular dependency, by adding a second binding. </li> </ol>"},{"location":"bestpractices/featuredisposal/","title":"Feature disposal","text":"<p>Never forget to call <code>feature.dispose()</code> when the context your <code>Feature</code> is living in goes away!</p> <p>A <code>Feature</code> is essentially a hot observable. It's neither invoked nor scoped by any subscribers to it. When its lifetime should end, you need to make sure any internal subscriptions it holds are released.</p>"},{"location":"binder/android/","title":"Lifecycle handling on Android","text":""},{"location":"binder/android/#using-androidbinderlifecycle-directly","title":"Using AndroidBinderLifecycle directly","text":"<p>You can use <code>AndroidBinderLifecycle</code> with any <code>LifecycleOwner</code> to automatically end <code>Binder</code> lifecycle upon <code>onDestroy()</code></p> <pre><code>override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    val binder = Binder(AndroidBinderLifecycle(this.lifecycle))\n    binder.bind(a to b)\n    binder.bind(c to d)\n}\n</code></pre>"},{"location":"binder/android/#using-androidbindings","title":"Using AndroidBindings","text":"<p>Better yet, don't put your bindings into your <code>Activity</code>. Rather, take a look at <code>AndroidBindings</code>, which creates you a <code>Binder</code> automatically:</p> <pre><code>abstract class AndroidBindings&lt;T : Any&gt;(\n    lifecycleOwner: LifecycleOwner\n) {\n    protected val binder = Binder(\n        lifecycle = AndroidBinderLifecycle(\n            androidLifecycle = lifecycleOwner.lifecycle\n        )\n    )\n\n    abstract fun setup(view: T)\n}\n</code></pre> <p>By extending this class, you can forget about <code>Binder</code> lifecycle and also extract the concern of creating your bindings:</p> <pre><code>// probably construct this using the DI framework of your choice:\nclass MyActivityBindings(\n    lifecycleOwner: LifecycleOwner,\n    private val feature: Feature,\n    private val viewModelTransformer: ViewModelTransformer,\n    private val uiEventTransformer: UiEventTransformer,\n    private val analyticsTracker: AnalyticsTracker\n) : AndroidBindings&lt;MyActivity&gt;(lifecycleOwner) {\n\n    override fun setup(view: MyActivity) {\n        binder.bind(feature to view using viewModelTransformer)\n        binder.bind(view to feature using uiEventTransformer)\n        binder.bind(view to analyticsTracker)\n    }\n}\n</code></pre> <p>Just inject it to your <code>Activity</code> and call <code>setup</code>:</p> <pre><code>class MyActivity : AppCompatActivity(), ObservableSource&lt;UiEvent&gt;, Consumer&lt;ViewModel&gt; {\n\n    @Inject lateinit var bindings: MyActivityBindings\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // TODO inject\n        bindings.setup(this)\n    }\n}\n</code></pre>"},{"location":"binder/binder-advanced/","title":"Advanced Binder usage","text":"<p>Note</p> <p>This section describes API that is optional and meant to help in specific cases.</p>"},{"location":"binder/binder-advanced/#changing-reactive-chain-between-input-and-output","title":"Changing reactive chain between input and output","text":"<p>As described here,  we can use a simple transformer to convert between output and input types. <pre><code>val output: ObservableSource&lt;A&gt; = TODO()\nval input: Consumer&lt;B&gt; = TODO()\nval transformer: (A) -&gt; B? = TODO()\n\nbinder.bind(output to input using transformer)\n</code></pre></p> <p>However, sometimes this is not enough. </p> <p>For more complex cases, we can use a <code>Connector&lt;A, B&gt;</code> instead, which is also able to manipulate the stream. <pre><code>object OutputToInput : Connector&lt;A, B&gt; {\n    override fun invoke(source: ObservableSource&lt;out A&gt;): ObservableSource&lt;B&gt; =\n        Observable.wrap(source)\n            // TODO transform stream\n            .map { a -&gt; TODO() }\n}\nval output: ObservableSource&lt;A&gt; = TODO()\nval input: Consumer&lt;B&gt; = TODO()\n\nbinder.bind(output to input using OutputToInput)\n</code></pre></p> <p>Note</p> <p>Try to keep your <code>Connector</code> simple. Common use-cases can be to add <code>.distinctUntilChanged()</code>, <code>.debounce()</code>, etc., but don't overcomplicate it!</p>"},{"location":"binder/binder-advanced/#naming-connections","title":"Naming connections","text":"<p>You can optionally give names to any connection: <pre><code>binder.bind(input to output named \"MyConnection\")\n// or\nbinder.bind(input to output using transformer named \"MyConnection\")\n</code></pre></p> <p>Naming a connection signals that it's important to you. This will make more sense when we'll add <code>Middlewares</code>:</p> <ul> <li>You'll see connections with their respective names in the time-travel debug menu</li> <li>You'll see connection names in logs if you use LoggingMiddleware</li> <li>You can opt to dynamically add <code>Middlewares</code> only to named connections (if that's what you want)</li> </ul>"},{"location":"binder/binder-advanced/#setting-connections-observation-scheduler","title":"Setting connections observation scheduler","text":"<p>You can optionally set the observation scheduler for any connection: <pre><code>binder.bind(input to output observeOn scheduler)\n</code></pre></p> <p>You can also use <code>Binder.observeOn</code> to reduce repetition: <pre><code>binder.observeOn(scheduler) {\n    bind(input1 to output1)\n    bind(input2 to output2)\n}\n</code></pre></p> <p>Specifying an observation scheduler ensures that the output is called on the specified scheduler.</p>"},{"location":"binder/binder/","title":"Binder usage and lifecycle","text":"<p>After 1.2.4, <code>Binder</code> is located in a separate module. You may need to add dependency on <code>com.github.badoo.mvicore:binder</code> to have it available.</p>"},{"location":"binder/binder/#what-is-the-binder-and-why-is-it-good-for-me","title":"What is the Binder and why is it good for me?","text":"<p>If you wrote your first <code>Feature</code>, now you may wonder how to start using it.</p> <p>Do you subscribe to its state directly? Do you call <code>.accept(wish)</code> on it manually?</p> <p>Well, you can, but there are better ways to do that, which also come with some bonuses.</p> <p>Remember when in the Core concepts we said that <code>Feature</code> is a <code>Consumer</code> of <code>Wish</code> and an <code>ObservableSource</code> of <code>State</code>? And that in general, the framework is working with outputs of type <code>ObservableSource&lt;T&gt;</code> and inputs of type <code>Consumer&lt;T&gt;</code>?</p> <p>The <code>Binder</code> is a tool that can:</p> <ul> <li>automatically connect those outputs to those inputs by a subscription using a super simple syntax</li> <li>dispose of this subscription when its lifecycle expires</li> <li>automatically add <code>Middlewares</code> around all inputs (logging and time travel debugging, or your custom one)</li> </ul>"},{"location":"binder/binder/#binder-creation","title":"Binder creation","text":"<p>Creating an instance is as simple as:</p> <pre><code>val binder = Binder()\n</code></pre> <p>with manual disposal, or</p> <pre><code>val binder = Binder(lifecycle)\n</code></pre> <p>for automatic disposal of the created bindings when lifecycle expires (more on that below).</p>"},{"location":"binder/binder/#binding-reactive-endpoints","title":"Binding reactive endpoints","text":"<p>You can connect outputs and inputs directly if they are of the same type: <pre><code>val output: ObservableSource&lt;A&gt; = TODO()\nval input: Consumer&lt;A&gt; = TODO()\n\nbinder.bind(output to input)\n</code></pre></p> <p>Or using a transformer if they are of different types: <pre><code>val output: ObservableSource&lt;A&gt; = TODO()\nval input: Consumer&lt;B&gt; = TODO()\nval transformer: (A) -&gt; B? = TODO()\n\nbinder.bind(output to input using transformer)\n</code></pre></p> <p>Note</p> <p>You can return <code>null</code> from transformer if the element emitted by an output should not reach the associated input. Binder will guarantee that null values are not forwarded in the stream.</p>"},{"location":"binder/binder/#lifecycle-handling","title":"Lifecycle handling","text":"<p>Since all connections created by the <code>Binder</code> are rx subscriptions under the hood, disposing needs to be taken care of.</p> <p>At the simplest:</p> <pre><code>val binder = Binder()\n\n// bind stuff\nbinder.bind(a to b)\nbinder.bind(c to d)\n\n// don't forget to call later\nbinder.dispose()\n</code></pre> <p>But you don't need to do this manually. <code>Binder</code> can take an instance of <code>Lifecycle</code> in its constructor, which is really only a way to signal termination:</p> <pre><code>interface Lifecycle : ObservableSource&lt;Lifecycle.Event&gt; {\n\n    enum class Event {\n        BEGIN,  // currently not used\n        END     // signals termination\n    }\n}\n</code></pre> <p>A <code>Lifecycle</code> instance can be created by mapping any other observable stream: <pre><code>val stream: Observable&lt;T&gt; = TODO()\nval lifecycle = Lifecycle.wrap(stream.map { Lifecycle.Event.END })\n</code></pre></p> <p>Or if you are on Android and using the <code>mvicore-android</code> dependency, you can leverage the <code>AndroidBinderLifecycle</code> class to automatically create Binder lifecycle from Android lifecycle: <pre><code>val lifecycle = AndroidBinderLifecycle(activity) // or any other Android LifecycleOwner\n</code></pre></p> <p>In both the above cases you don't need to worry about disposing: whenever <code>Lifecycle</code> signals it, the <code>Binder</code> instance will dispose of the created subscriptions:</p> <pre><code>val binder = Binder(lifecycle)\n\n// bind stuff\nbinder.bind(a to b)\nbinder.bind(c to d)\n\n// no need to dispose manually, will be handled automatically\n</code></pre>"},{"location":"binder/binding/","title":"Binding Features to the UI (and other reactive components)","text":""},{"location":"binder/binding/#i-have-my-feature-now-what","title":"I have my Feature, now what?","text":"<p>Let's take a step by step approach how to connect our Features to the UI.</p> <p>Let's suppose we have:</p> <ul> <li><code>Feature1&lt;Wish, State&gt;</code></li> <li><code>Binder</code> instance</li> <li>A View, where we want to render the state of <code>Feature1</code>, and trigger some <code>Wish</code>es on them.</li> </ul>"},{"location":"binder/binding/#step-1-direct-binding","title":"Step 1: Direct binding","text":"<pre><code>class View : Consumer&lt;Feature1.State&gt; {\n\n    val binder: Binder = TODO()\n    val feature: Feature1 = TODO()\n\n    val button: Button = TODO()\n    val counter: TextView = TODO()\n    val image: ImageView = TODO()\n    val progress: ProgressBar = TODO()\n\n    fun onCreate() {\n        setupBindings()\n        setupViews()\n    }\n\n    fun setupBindings() {\n        binder.bind(feature to this)\n    }\n\n    private fun setupViews() {\n        button.setOnClickListener {\n            // directly talking to feature\n            feature.accept(Feature1.Wish.Foo)\n        }\n    }\n\n    override fun accept(state: Feature1.State) {\n        counter.text = (state.counter1 + state.counter2) % 2 // \"complex logic\"\n        image.url = state.imageUrls.first { it.contains(\"imgur\") } // \"complex logic\"\n        if (state.isLoading) progress.visible() else progress.hide()\n    }\n}\n</code></pre> <p>In this example, <code>View</code> accepts <code>State</code> directly, and talks to <code>Feature1</code> directly. This is wrong for multiple reasons:</p> <ul> <li>The <code>View</code> is now tightly coupled to <code>Feature1</code></li> <li>The <code>View</code> really shouldn't care where it gets the data it wants to display on the screen from. It shouldn't render data models, but rather view models that doesn't require local logic to transform (see the comments about \"complex logic\").</li> <li>The <code>View</code> has the additional responsibility of managing bindings</li> </ul> <p>Let's fix these one by one.</p>"},{"location":"binder/binding/#step-2-extract-bindings","title":"Step 2: Extract bindings","text":"<pre><code>class Bindings @Inject constructor(\n    private val feature: Feature1\n) {\n    val binder: Binder = TODO()\n\n    fun setup(view: View) {\n        binder.bind(feature to view)\n    }\n}\n</code></pre> <p>Now the extra concern is lifted from the <code>View</code>, and it only cares about its input (<code>State</code>) and output (triggering <code>Wish</code>). But let's not stop here.</p>"},{"location":"binder/binding/#step-3-dont-render-the-state-render-a-viewmodel","title":"Step 3: Don't render the State, render a ViewModel","text":"<p>Define your <code>ViewModel</code> however you see fit. It should contain processed, \"dumb\", simple to display data only, and only what is actually required for your <code>View</code>: <pre><code>data class ViewModel(\n    val counter: Int,\n    val imageUrl: String,\n    val isLoading: Boolean\n)\n</code></pre></p> <p>Convert the <code>State</code> to a <code>ViewModel</code> with a <code>ViewModelTransformer</code>:</p> <pre><code>object ViewModelTransformer : (Feature1.State) -&gt; ViewModel {\n\n    override fun invoke(state: Feature1.State): ViewModel =\n        ViewModel(\n            // 1. If the State stores data in another / more complex format,\n            //      mapping to simple values should be done here, and not in the View\n            // 2. Also the State might contain a lot more stuff,\n            //      here we only pass on those actually needed for the View\n            counter = (state.counter1 + state.counter2) % 2,\n            imageUrl = state.imageUrls.first { it.contains(\"imgur\") },\n            isLoading = state.isLoading\n        )\n}\n</code></pre> <p>Modify <code>View</code> to consume <code>ViewModel</code>, it becomes much simpler without data model parsing logic:</p> <pre><code>class View : Consumer&lt;ViewModel&gt; {\n\n    // remainder omitted\n\n    override fun accept(vm: ViewModel) {\n        counter.text = vm.counter\n        image.url = vm.imageUrl\n        if (state.isLoading) progress.visible() else progress.hide()\n    }\n}\n</code></pre> <p>Modify the <code>Bindings</code> so that it uses the <code>ViewModelTransformer</code></p> <pre><code>class Bindings @Inject constructor(\n    private val feature: Feature1\n) {\n    val binder: Binder = TODO()\n\n    fun setup(view: View) {\n        binder.bind(feature to view using ViewModelTransformer)\n    }\n}\n</code></pre> <p>Now the <code>View</code> doesn't care where it gets its <code>ViewModel</code> from, and can be reused to work with other data sources as well.</p>"},{"location":"binder/binding/#step-3-dont-emit-wish-emit-a-ui-event","title":"Step 3: Don't emit Wish, emit a UI Event","text":"<p>There's one last thing that's still coupling our <code>View</code> to our <code>Feature1</code> \u2014 triggering its <code>Wish</code>es directly. Now that the <code>View</code> doesn't know where the <code>ViewModel</code> comes from, why should it talk to <code>Feature1</code> directly? All it really cares about it is to provide some output. The fact that this can trigger state changes and a new <code>ViewModel</code> to render is secondary from its perspective.</p> <p>Let's define our UI events as:</p> <pre><code>sealed class UiEvent {\n    object ButtonClicked : UiEvent()\n    object ImageClicked : UiEvent()\n}\n</code></pre> <p>Let's remove the <code>Feature1</code> reference from our <code>View</code>, and make it a source of <code>UiEvent</code>s</p> <pre><code>class View(\n    private val uiEvents: PublishRelay&lt;UiEvent&gt; = PublishRelay.create()\n) : Consumer&lt;ViewModel&gt;, ObservableSource&lt;UiEvent&gt; by uiEvents {\n\n    // remainder omitted\n\n    private fun setupViews() {\n        button.setOnClickListener { uiEvents.accept(UiEvent.ButtonClicked) }\n        image.setOnClickListener { uiEvents.accept(UiEvent.ImageClicked) }\n    }\n}\n</code></pre> <p>Now we can connect our <code>View</code> to our <code>Feature1</code> using a transformer, much like how we did with <code>State</code> -&gt; <code>ViewModel</code>, only this time it's in the other direction:</p> <pre><code>object UiEventTransformer : (UiEvent) -&gt; Feature1.Wish? {\n    override fun invoke(event: UiEvent): Feature1.Wish? = when (event) {\n        is ButtonClicked -&gt; Feature1.Wish.SetActiveButton(event.idx)\n        is PlusClicked -&gt; Feature1.Wish.IncreaseCounter\n    }\n}\n</code></pre> <pre><code>class Bindings @Inject constructor(\n    private val feature: Feature1\n) {\n    val binder: Binder = TODO()\n\n    fun setup(view: View) {\n        binder.bind(view to feature using UiEventTransformer)\n        binder.bind(feature to view using ViewModelTransformer)\n    }\n}\n</code></pre>"},{"location":"binder/binding/#step-4-profit","title":"Step 4: Profit","text":"<p>Let's consider the benefits so far:</p> <ul> <li>We completely decoupled our UI and our business logic.</li> <li>Our <code>View</code> doesn't know anything about a <code>Feature</code>, it only knows how to render <code>ViewModels</code> and how to trigger <code>UiEvents</code>, and has become a reusable unit in itself.</li> <li>It can be fed <code>ViewModels</code> from any other source.</li> <li>Bindings, along with their lifecycle, are a separate concern.</li> </ul> <p>Additionally, now that we trigger <code>UiEvents</code> in the <code>View</code>, we can bind multiple other components to it in a completely decoupled way!</p> <p>Let's add an analytics tracker:</p> <pre><code>class AnalyticsTracker() : Consumer&lt;UiEvent&gt; {\n\n    override fun accept(uiEvent: UiEvent) {\n        when (uiEvent) {\n            is ButtonClicked -&gt; TODO()\n            is PlusClicked -&gt; TODO()\n        }\n    }\n}\n</code></pre> <p>And now we can connect it with just one additional line in our <code>Bindings</code>:</p> <pre><code>class Bindings @Inject constructor(\n    private val feature: Feature1\n    private val analyticsTracker: AnalyticsTracker\n) {\n    val binder: Binder = TODO()\n\n    fun setup(view: View) {\n        binder.bind(view to analyticsTracker)\n        binder.bind(view to feature using UiEventTransformer)\n        binder.bind(feature to view using ViewModelTransformer)\n    }\n}\n</code></pre> <p>All this without modifying anything in our <code>View</code>!</p> <p>Once you add multiple reactive components, the <code>Bindings</code> class becomes your high level overview of the whole graph of who talks to whom, in a really descriptive way.</p>"},{"location":"extras/inspectorplugin/","title":"Inspector plugin","text":""},{"location":"extras/inspectorplugin/#android-studio-plugin-to-observe-elements-of-connections","title":"Android Studio plugin to observe elements of connections","text":"<p>Note</p> <p>This plugin is still under development (requires MVICore 1.2.0 or later)</p> <p>Allows to record elements passed through middlewares and inspect their values.</p>"},{"location":"extras/inspectorplugin/#how-to-use","title":"How to use","text":"<ol> <li>Download MVICoreInspector.zip</li> <li>Inside the IDE go to \"Install plugin from disk...\"</li> <li>Install the .zip file and restart the IDE</li> <li>Add plugin middleware artifact to your dependencies: <code>implementation\u00a0\"com.github.badoo.mvicore:mvicore-plugin-middleware:$VERSION\"</code></li> <li>Setup middleware configuration:     <pre><code>// Create store\nval store = DefaultPluginStore(BuildConfig.APPLICATION_ID)\n\n// Apply middleware\nMiddlewares.configurations.add(\n     MiddlewareConfiguration(\n         condition = WrappingCondition.Always,\n         factories = listOf(\n             { consumer -&gt; IdeaPluginMiddleware(consumer, store) }\n         )\n     )\n)\n</code></pre></li> <li>Don't forget to add permission in AndroidManifest.xml: <code>&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;</code>. The plugin uses socket connection, which will not work without it.</li> <li>Connect device, so it is visible to the IDE. Run your app.</li> <li>Once app is running, press Run icon in the MVICore panel.</li> </ol> <p>The pane contains three sections:</p> <ul> <li>Left - List of events passed through middlewares.</li> <li>Right top - List of active connections. You can filter events by selecting connections.</li> <li>Right bottom - Currently selected event from the left part. Displays event data and connection it was sent from.</li> </ul>"},{"location":"extras/modelwatcher/","title":"Efficient view updates","text":"<p>MVICore includes utility class to observe difference in the received models and prevent redundant view updates.</p> <pre><code>data class ViewModel(\n    val buttonText: String,\n    val buttonAction: () -&gt; Unit,\n    val isLoading: Boolean\n)\n\nclass View: Consumer&lt;ViewModel&gt; {\n\n    private val button: Button = ...\n\n    // Specify the fields to observe and actions to execute\n    private val watcher = modelWatcher&lt;ViewModel&gt; {\n        watch(ViewModel::buttonText) {\n            button.text = it\n        }\n        watch(ViewModel::buttonAction, diff = byRef()) {\n            button.setOnClickListener { it() }\n        }\n    }\n\n    override fun accept(model) {\n        // Pass the model\n        watcher.invoke(model)\n    }\n}\n</code></pre> <p>By default, the difference is calculated by value (using <code>equals</code>). It is configurable through <code>diff</code> parameter. The library also includes a couple of commonly used defaults.</p> <pre><code>val watcher = modelWatcher&lt;Model&gt; {\n    watch(Model::field, diff = byValue()) {  } // Compare using equals (default strategy)\n    watch(Model::field, diff = byRef()) { }    // Compare using referential equality   \n}\n</code></pre> <p>The difference can be observed on more than one field with custom diff strategy.  For example, if the click listener should not be set when something is loading, you can do the following: <pre><code>// Trigger when either loading flag or action changed\nval loadingOrAction: DiffStrategy&lt;ViewModel&gt; = { p1, p2 -&gt;\n    p1.isLoading != p2.isLoading || p1.buttonAction !== p2.buttonAction\n}\n\nval watcher = modelWatcher&lt;ViewModel&gt; {\n    watch({ it }, diff = loadingOrAction) { model -&gt;\n        // Allow action only when not loading\n        button.setOnClickListener(\n            if (!model.isLoading) model.buttonAction else null\n        )\n    }\n}\n</code></pre></p> <p>Models based on the sealed classes are supported with <code>type</code> and <code>objectType</code> functions. <pre><code>sealed class Model {\n    data class A(val list: List&lt;String&gt;): Model()\n    object B : Model()\n}\n\nval watcher = modelWatcher&lt;Model&gt; {\n    type&lt;A&gt; {\n        watch(Model.A::list) { }\n    }\n\n    objectType&lt;B&gt; { modelB -&gt;\n\n    }\n}\n</code></pre></p> <p>Warning</p> <p>Subsequent definitions of the same type will override previous ones.</p> <p>If sealed class has a common property defined in the base class, its changes can be observed as well. In the example below, <code>Model::list</code> selector is triggered when the property is changed independently on model type. <pre><code>sealed class Model {\n    abstract val list: List&lt;String&gt;\n\n    data class A(val list: List&lt;String&gt;): Model()\n    object B : Model() {\n        override val list: List&lt;String&gt; = emptyList()\n    }\n}\n\nval watcher = modelWatcher&lt;Model&gt; {\n    type&lt;A&gt; {\n        watch(Model.A::list) { \n            // Property of Model.A only\n        }\n    }\n\n    watch(Model::list) {\n        // Common property\n    }\n}\n</code></pre></p> <p>The watcher also provides an optional DSL to add more clarity to the definitions: <pre><code>val watcher = modelWatcher&lt;ViewModel&gt; {\n    // Method call\n    watch(ViewModel::buttonText) {\n        button.text = it\n    }\n\n    // DSL\n    ViewModel::buttonText {\n       button.text = it\n    }\n}\n</code></pre> The same applies to custom strategies. <pre><code>val watcher = modelWatcher&lt;ViewModel&gt; {\n    // Method call\n    watch(Model::buttonAction, diff = byRef()) { }\n\n    // DSL\n    val byRef = byRef&lt;() -&gt; Unit&gt;()\n    ViewModel::buttonAction using byRef {\n\n    }\n}\n</code></pre> Common strategies on two fields can be defined in a simpler way. <pre><code>val watcher = modelWatcher&lt;ViewModel&gt; {\n    // Method call\n    val loadingOrAction: DiffStrategy&lt;ViewModel&gt; = { p1, p2 -&gt;\n        p1.isLoading != p2.isLoading || p1.buttonAction !== p2.buttonAction\n    }\n    watch({ it }, loadingOrAction) {\n\n    }\n\n    // DSL\n    (ViewModel::isLoading or ViewModel::buttonAction) {\n\n    }\n}\n</code></pre></p>"},{"location":"extras/templategeneratorplugin/","title":"Template generator plugin","text":""},{"location":"extras/templategeneratorplugin/#intellij-plugin-to-generate-feature-templates","title":"IntelliJ plugin to generate Feature templates","text":"<p>You can find a plugin for IntelliJ in the repo which contains file templates to default <code>Feature</code> implementations.</p>"},{"location":"extras/templategeneratorplugin/#how-to-use","title":"How to use","text":"<ol> <li>Download MVICoreFileTemplates.jar</li> <li>Inside the IDE go to \"Install plugin from disk...\"</li> <li>Install the .jar file and restart the IDE</li> <li>In the project tree select any package and pop up the \"New...\" context menu</li> <li>You can filter the options by typing \"feature\"</li> <li>Pick one</li> <li>Enter a name for your new file</li> <li>Profit</li> </ol>"},{"location":"extras/ttdui/","title":"Time Travel Debugger UI controls","text":"<p>If you are on Android and using DebugDrawer, you can find a UI control module you can add to it in the <code>mvicore-debugdrawer</code> dependency.</p> <p></p> <p>UI controls include:</p> <ul> <li>start recording</li> <li>stop recording</li> <li>start playback</li> <li>record selection dropdown, which automatically updates itself with all records available in the RecordStore</li> </ul>"},{"location":"features/actorreducerfeature/","title":"Handling async jobs","text":""},{"location":"features/actorreducerfeature/#actor","title":"Actor","text":"<p>If you have</p> <ul> <li>anything asynchronous</li> <li>more complex requirements how some <code>Wish</code> will modify the <code>State</code></li> </ul> <p>then now we need to distinguish between</p> <ul> <li>incoming <code>Wish</code></li> <li>an actual <code>Effect</code> that is applied over the <code>State</code> using the <code>Reducer</code></li> </ul> <p>And now we need a mapping between the two. The <code>Actor</code> is basically a function doing just that:</p> <pre><code>typealias Actor&lt;State, Wish, Effect&gt; = (State, Wish) -&gt; Observable&lt;out Effect&gt;\n</code></pre> <p>This means that now we can consider an incoming <code>Wish</code> and our current <code>State</code>, and based on them we can do some operations that will emit <code>Effect</code>s to change our <code>State</code>.</p> <p>Note</p> <p>The operations do not have to be asynchronous. You can still use <code>Observable.just()</code> to return one or more <code>Effect</code>s immediately. The added power here is that you can do that conditionally based on the current <code>State</code></p> <p>E.g. your <code>Feature</code> represents a form, and then based on the result of form validation over the current state, you can emit different <code>Effect</code>s to signal validation success or error.</p>"},{"location":"features/actorreducerfeature/#important","title":"Important","text":"<p>Since invocations of the reducer must always happen on the same thread, you must ensure that you observe results of your asynchronous jobs on that thread. In Android, this practically means calling <code>.observeOn(AndroidSchedulers.mainThread())</code></p>"},{"location":"features/actorreducerfeature/#excercise-2","title":"Excercise #2","text":""},{"location":"features/actorreducerfeature/#task","title":"Task","text":"<ul> <li>Let's talk to an async service to load some data</li> <li>Let's signal whether we are in progress of loading, successfully loaded, or if an error has happened</li> </ul>"},{"location":"features/actorreducerfeature/#solution-using-actorreducerfeature","title":"Solution using ActorReducerFeature","text":"<pre><code>class Feature2 : ActorReducerFeature&lt;Wish, Effect, State, Nothing&gt;(\n    initialState = State(),\n    actor = ActorImpl(),\n    reducer = ReducerImpl()\n) {\n\n    data class State(\n        val isLoading: Boolean = false,\n        val payload: String? = null\n    )\n\n    sealed class Wish {\n        object LoadNewData : Wish()\n    }\n\n    sealed class Effect {\n        object StartedLoading : Effect()\n        data class FinishedWithSuccess(val payload : String) : Effect()\n        data class FinishedWithError(val throwable: Throwable) : Effect()\n    }\n\n    class ActorImpl : Actor&lt;State, Wish, Effect&gt; {\n        private val service: Observable&lt;String&gt; = TODO()\n\n        override fun invoke(state: State, wish: Wish): Observable&lt;Effect&gt; = when (wish) {\n            is LoadNewData -&gt; {\n                if (!state.isLoading) {\n                    service\n                        .observeOn(AndroidSchedulers.mainThread())\n                        .map { FinishedWithSuccess(payload = it) as Effect }\n                        .startWith(StartedLoading)\n                        .onErrorReturn { FinishedWithError(it) }\n                }\n                else {\n                    Observable.empty()\n                }\n            }\n        }\n    }\n\n    class ReducerImpl : Reducer&lt;State, Effect&gt; {\n        override fun invoke(state: State, effect: Effect): State = when (effect) {\n            is StartedLoading -&gt; state.copy(\n                isLoading = true\n            )\n            is FinishedWithSuccess -&gt; state.copy(\n                isLoading = false,\n                payload = effect.payload\n            )\n            is FinishedWithError -&gt; state.copy(\n                isLoading = false\n            )\n        }\n    }\n}\n</code></pre> <p>Under the hood, <code>ActorReducerFeature</code> is a subclass of <code>BaseFeature</code> giving you a subset of all the possibilities there.</p> <p>It will also wire everything up for you (reacting to a <code>Wish</code>, calling your <code>Actor</code> and subscribing to the <code>Observable&lt;Effect&gt;</code> returned by it, and calling your <code>Reducer</code> to emit your next <code>State</code>).</p> <p>Note</p> <p>In this example, the error result is not stored in the state. The preferred way in most cases is an event-based approach seen in the chapter News and inter-feature communication</p> <p>But if you need it, you can still add a field in the <code>State</code> to store the error, just don't forget to reset it in the <code>Reducer</code> upon the next <code>StartedLoading</code> or <code>FinishedWithSuccess</code> effects.</p> <p>Another approach would be to use a Kotlin sealed class, or the functional <code>Either&lt;A, B&gt;</code> type for the payload, where <code>A</code> would be the error, <code>B</code> would be actual data. Really only up to you.</p>"},{"location":"features/actorreducerfeature/#when-should-you-use-actorreducerfeature","title":"When should you use ActorReducerFeature","text":"<ul> <li>There are async jobs in your Feature</li> <li>There's some extra business logic involving how to react to a <code>Wish</code> conditionally</li> </ul>"},{"location":"features/bootstrappers/","title":"Bootstrappers","text":""},{"location":"features/bootstrappers/#listening-to-remote-sources","title":"Listening to remote sources","text":"<p>So far all of the triggers to our <code>Feature</code>s were internal:</p> <ul> <li><code>Wish</code>es come from client code</li> <li><code>Action</code>s are triggered inside <code>Feature</code> in the <code>PostProcessor</code></li> </ul> <p>But what if you need to react to let's say when the server sends you a push? You can of course listen to them outside of your <code>Feature</code> and then push <code>Wish</code>es, but this has its own disadvantages:</p> <ul> <li>Part of your business logic is now living outside of your class. If you are passing your component around for others to use, everyone will need to pay attention how to set it up. This is not correct.</li> <li>From outside you can only trigger public <code>Wish</code>es, not <code>Action</code>s</li> </ul> <p>The <code>Bootstrapper</code> is solving exactly these problems.</p>"},{"location":"features/bootstrappers/#bootstrapper","title":"Bootstrapper","text":"<p>It's defined as:</p> <pre><code>typealias Bootstrapper&lt;Action&gt; = () -&gt; Observable&lt;Action&gt;\n</code></pre> <p>which practically means, that when invoked, it can give you a stream of <code>Action</code>s. You can use this interface to add initial wiring to your <code>Feature</code>:</p> <pre><code>class BootstrapperImpl : Bootstrapper&lt;Action&gt; {\n    private val service1: Observable&lt;Any&gt; = TODO()\n    private val service2: Observable&lt;Any&gt; = TODO()\n\n    override fun invoke(): Observable&lt;Action&gt; = Observable.merge&lt;Action&gt;(\n        service1.map { InvalidateCache },\n        service2.map { ReloadSomething }\n    ).observeOn(AndroidSchedulers.mainThread())\n}\n</code></pre> <p>Pass your <code>Bootstrapper</code> implementation in the constructor to either <code>ReducerFeature</code>, <code>ActorReducerFeature</code>, or <code>BaseFeature</code>:</p> <pre><code>class MyComplexFeature : BaseFeature&lt;Wish, Action, Effect, State, News&gt;(\n    // ...remainder omitted...\n    bootstrapper = BootstrapperImpl()\n)\n</code></pre> <p>The implementation of <code>BaseFeature</code> wires it up for you.</p>"},{"location":"features/bootstrappers/#bootstrapping-is-immediate-by-default","title":"Bootstrapping is immediate by default","text":"<p>As noted in the core concepts section, <code>Features</code> are essentially hot observables. It's worth to repeat this here, because there's an important aspect of it here: <code>Bootstrapper</code> is invoked immediately on <code>Feature</code> creation and by default will not wait for anything else.</p> <p>You can picture the <code>Feature</code> as if it was a glorified <code>BehaviourSubject</code>: when you create that with <code>createDefault</code>, it emits its first state straight away and continues to emit whatever is put into it after creation.</p>"},{"location":"features/bootstrappers/#delaying-bootstrapping","title":"Delaying bootstrapping","text":"<p>If you need to delay bootstrapping for any reason, you can refer to the corresponding best practices section: delaying bootstrapping</p>"},{"location":"features/coreconcepts/","title":"Core concepts","text":""},{"location":"features/coreconcepts/#sources-and-consumers","title":"Sources and consumers","text":"<p>MVICore works with sources and consumers of observable data at its heart.</p> <p>That is:</p> <ul> <li>outputs are of type <code>ObservableSource&lt;T&gt;</code></li> <li>inputs are of type <code>Consumer&lt;T&gt;</code></li> </ul>"},{"location":"features/coreconcepts/#stores","title":"Stores","text":"<p>The <code>Store&lt;Wish, State&gt;</code> interface defines the outline of a state machine that - can receive objects of type <code>Wish</code> on its input - can produce objects of type <code>State</code> on its output - in addition, it holds on to the latest <code>State</code>, which can be queried without subscribing to the Store</p> <pre><code>interface Store&lt;Wish : Any, State : Any&gt; : Consumer&lt;Wish&gt;, ObservableSource&lt;State&gt; {\n\n    val state: State\n}\n</code></pre> <p><code>State</code> is meant to be immutable, for which we'll use Kotlin data classes.</p>"},{"location":"features/coreconcepts/#features","title":"Features","text":"<p>A <code>Feature</code> is a <code>Store</code> with the addition of:</p> <ul> <li>being <code>Disposable</code>, as it might hold subscriptions</li> <li>being a source of <code>News</code></li> </ul> <pre><code>interface Feature&lt;Wish : Any, State : Any, News: Any&gt; : Store&lt;Wish, State&gt;, Disposable {\n\n    val news: ObservableSource&lt;News&gt;\n}\n</code></pre> <p><code>News</code> marks the type of the events a <code>Feature</code> can emit. These are pieces of information you don\u2019t want to store in the state, just fire off once when they happen.</p> <p>More about that in the chapter Events that should be consumed only once.</p>"},{"location":"features/coreconcepts/#features-are-hot-observables","title":"Features are hot observables","text":"<p><code>Features</code> are not cold observables: they do not wait for subscriptions to start working, and they are not scoped by subscriptions to them. They are push-based (pushing out new states automatically) and not pull-based (producing something upon a subscription). </p> <p>This is a designed feature of the library.</p> <p><code>Features</code> are supposed to be able to be active in the background, and have possibly many, differently scoped inputs / outputs to them. </p> <p>Two things follow from this:</p> <ol> <li>A <code>Feature</code> starts working immediately on creation, and emits its initial state.</li> <li>A <code>Feature</code> always needs to be disposed of when its lifecycle should end. That means it's your responsibility to call <code>.dispose()</code> on it, so that any asynchronous jobs still executing are properly disposed of.</li> </ol> <p>Bottom line</p> <p>Don't forget to call <code>.dispose()</code> at the end of the <code>Feature</code>'s lifecycle</p>"},{"location":"features/fullfeatured/","title":"Going full-featured","text":""},{"location":"features/fullfeatured/#basefeature","title":"BaseFeature","text":"<p>If the reduced functionality of ReducerFeature and ActorReducerFeature is not enough for your case, this base class is your go-to.</p> <p>BaseFeature takes four generic parameters:</p> <p><code>BaseFeature&lt;Wish, Action, Effect, State&gt;</code></p> <p>The new one here compared to the simpler Features is the <code>Action</code>.</p>"},{"location":"features/fullfeatured/#actions","title":"Actions","text":"<p>Use-case:</p> <ul> <li>you need some kind of an \"internal <code>Wish</code>\" to execute, but you don't want to leak it through your <code>Wish</code> sealed class, as it would make it publicly callable.</li> <li>you want to be able to trigger these \"internal <code>Wish</code>es\"</li> </ul> <p><code>Action</code> is a superset of <code>Wish</code> in the form of:</p> <pre><code>sealed class Wish {\n    object PublicWish1 : Wish()\n    object PublicWish2 : Wish()\n    object PublicWish3 : Wish()\n}\n\nsealed class Action {\n    data class Execute(val wish: Wish) : Action()\n    object InvalidateCache : Action()\n    object ReloadSomething : Action()\n}\n</code></pre> <p>This has two implications:</p> <ol> <li> <p>For <code>BaseFeature</code> to know how your public <code>Wish</code> maps to an <code>Action</code>, you need to supply a mapping function in the constructor <pre><code>typealias WishToAction&lt;Wish, Action&gt; = (Wish) -&gt; Action\n</code></pre></p> </li> <li> <p>Now your <code>Actor</code> will be acting upon <code>Action</code> instead of <code>Wish</code></p> </li> </ol> <p>So any incoming <code>Wish</code> is mapped to an <code>Action</code>, and executed in the <code>Actor</code> along with all other <code>Action</code>s:</p> <pre><code>class MyComplexFeature : BaseFeature&lt;Wish, Action, Effect, State&gt;(\n    // ...remainder omitted...\n    wishToAction = { Execute(it) },\n    actor = ActorImpl(),\n) {\n    // ...remainder omitted...\n\n    sealed class Wish {\n        object PublicWish1 : Wish()\n        object PublicWish2 : Wish()\n        object PublicWish3 : Wish()\n    }\n\n    sealed class Action {\n        data class Execute(val wish: Wish) : Action()\n        object InvalidateCache : Action()\n        object ReloadSomething : Action()\n    }\n\n    class ActorImpl : Actor&lt;State, Action, Effect&gt; {\n        override fun invoke(state: State, action: Action): Observable&lt;Effect&gt; = when (action) {\n            is Execute -&gt; when (action.wish) {\n                PublicWish1 -&gt; TODO()\n                PublicWish2 -&gt; TODO()\n                PublicWish3 -&gt; TODO()\n            }\n            InvalidateCache -&gt; TODO()\n            ReloadSomething -&gt; TODO()\n        }\n    }\n\n    // ...remainder omitted...\n}\n</code></pre> <p>So now you can have internal <code>Action</code>s, but how will you trigger them? Meet the <code>PostProcessor</code>.</p>"},{"location":"features/fullfeatured/#postprocessor","title":"PostProcessor","text":"<p>The <code>PostProcessor</code> (as the name implies) will have a chance to react after a certain <code>Action</code> was mapped to a certain <code>Effect</code> which was used to create a new <code>State</code>. At this point, it can signal the need for additional <code>Action</code>s:</p> <pre><code>typealias PostProcessor&lt;Action, Effect, State&gt; = (Action, Effect, State) -&gt; Action?\n</code></pre> <p>Using the example above this could be:</p> <pre><code>class MyComplexFeature : BaseFeature&lt;Wish, Action, Effect, State&gt;(\n    // ...remainder omitted...\n    postProcessor = PostProcessorImpl()\n) {\n   // ...remainder omitted...\n\n   class PostProcessorImpl : PostProcessor&lt;Action, Effect, State&gt; {\n           // do anything based on action (contains wish), effect, state\n           override fun invoke(action: Action, effect: Effect, state: State): Action? {\n               if (state.i == 101) {\n                   return InvalidateCache\n               }\n\n               return null\n           }\n       }\n}\n</code></pre> <p>The implementation of <code>BaseFeature</code> wires everything up for you from mapping your <code>Wish</code> to <code>Action</code>, calling your <code>Actor</code>, <code>Reducer</code>, and <code>PostProcessor</code> and emitting the next <code>State</code>.</p>"},{"location":"features/news/","title":"Events that should be consumed only once","text":""},{"location":"features/news/#news","title":"News","text":"<p>As we\u2019ve seen, the <code>Feature</code> interface has a third generic type of <code>News</code>:</p> <pre><code>interface Feature&lt;Wish : Any, State : Any, News: Any&gt; : Store&lt;Wish, State&gt;, Disposable {\n\n    val news: ObservableSource&lt;News&gt;\n}\n</code></pre> <p>News is the type that a Feature can use for signaling single events. This is to address a recurring issue with MVI approaches: how do you handle events that should be consumed only once? For example, a toast / snackbar message, or a redirect event.</p> <p>If you store this information in the state, then it will remain there until you clear it - and until that is done, all subsequent subscribers to that state will receive it again. Sometimes that\u2019s just what you want, but it\u2019s also a valid case, that showing those messages later again makes no sense (if they are outdated and irrelevant now), or that going back to a screen which still holds a redirect order in its state will cause you problems.</p> <p>The approach in this library is to create a separation between states and events, and not store the latter in the previous in any form. Rather, all <code>Feature</code> implementations can have their very own <code>NewsPublisher</code>:</p> <pre><code>typealias NewsPublisher&lt;Action, Effect, State, News&gt; = (Action, Effect, State) -&gt; News?\n</code></pre> <p>Its invocation has access to all the parameters of the current execution chain (which action triggered which effect, which resulted in what new state), and by implementing it you can fabricate any condition based on those to signal emitting <code>News</code>.</p> <p>You can pass a <code>NewsPublisher</code> implementation in your constructor to the base classes, and the framework will make sure to call it after each new state emission. Any <code>News</code> produced by it will then be observable through the <code>news</code> property of the feature automatically:</p> <pre><code>class FeatureImpl : ActorReducerFeature&lt;Wish, Effect, State, News&gt;(\n    // ...remainder omitted...\n    newsPublisher = NewsPublisherImpl()\n) {\n\n    // ...remainder omitted...\n\n    sealed class Effect {\n        // ...remainder omitted...\n        data class ErrorLoading(val throwable : Throwable) : Effect()\n    }\n\n    sealed class News {\n        data class ErrorExecutingRequest(val throwable: Throwable) : News()\n    }\n\n    class NewsPublisherImpl : NewsPublisher&lt;Wish, Effect, State, News&gt; {\n        override fun invoke(wish: Wish, effect: Effect, state: State): News? = when (effect) {\n            is ErrorLoading -&gt; News.ErrorExecutingRequest(effect.throwable)\n            else -&gt; null\n        }\n    }\n}\n</code></pre> <p>So how is this beneficial to you?</p> <p>To sum it up, using this approach allows you to:</p> <ul> <li>React on single events which would be probably inconvenient to store in the State</li> <li>React to what happened rather than how it changed the state</li> </ul>"},{"location":"features/reducerfeature/","title":"Your first and simplest feature","text":""},{"location":"features/reducerfeature/#reducer","title":"Reducer","text":"<p>Your simplest <code>Feature</code> would be one which only uses a <code>Reducer</code> to create and emit new states based on the latest one and an incoming effect.</p> <p>The Reducer is basically a function defining just that:</p> <pre><code>typealias Reducer&lt;State, Effect&gt; = (State, Effect) -&gt; State\n</code></pre> <p>The name <code>Effect</code> is used here in the more generic context.</p> <p>Note</p> <p>Later there will be a distinction between <code>Wish</code>es and <code>Effect</code>s, but for now, they are one and the same in this simplest example.</p>"},{"location":"features/reducerfeature/#important","title":"Important","text":"<p>Invocations of the reducer must always happen on the same thread to ensure that new <code>Effect</code>s are always applied to the latest <code>State</code> and we are not losing modifications.</p> <p>If two threads were to read State<sup>n</sup>, then apply some <code>Effect</code> over it, one would derive State<sup>n+1'</sup>, while the other would derive  State<sup>n+1''</sup> from it, and depending on the order of execution, one or the other would be lost. By enforcing the single-thread policy, all <code>Effect</code>s are always applied to the latest state.</p>"},{"location":"features/reducerfeature/#exercise-1","title":"Exercise #1","text":""},{"location":"features/reducerfeature/#task","title":"Task","text":"<ul> <li>Let's store a counter in our state</li> <li>Let's make it possible to increment this counter by a <code>Wish</code></li> </ul>"},{"location":"features/reducerfeature/#solution-using-reducerfeature","title":"Solution using ReducerFeature","text":"<p>Meet the simplest <code>Feature</code>, the <code>ReducerFeature</code>:</p> <pre><code>class Feature1 : ReducerFeature&lt;Wish, State, Nothing&gt;(\n    initialState = State(),\n    reducer = ReducerImpl()\n) {\n\n    data class State(\n        val counter: Int = 0\n    )\n\n    sealed class Wish {\n        object IncrementCounter : Wish()\n    }\n\n    class ReducerImpl : Reducer&lt;State, Wish&gt; {\n        override fun invoke(state: State, wish: Wish): State = when (wish) {\n            IncrementCounter -&gt; state.copy(\n                counter = state.counter + 1\n            )\n        }\n    }\n}\n</code></pre> <p>Under the hood, <code>ReducerFeature</code> is a subclass of <code>BaseFeature</code> giving you a subset of all the possibilities there.</p> <p>It will also wire everything up for you (reacting to a <code>Wish</code>, calling your <code>Reducer</code>, emitting your next <code>State</code>).</p>"},{"location":"features/reducerfeature/#when-should-you-use-reducerfeature","title":"When should you use ReducerFeature","text":"<ul> <li>There are no async jobs in your Feature</li> <li>There's no extra business logic. Whatever comes in as a <code>Wish</code>, always modifies the <code>State</code> without a question, and we just want to keep track of it.</li> </ul>"},{"location":"features/timecapsule/","title":"Saving / restoring Feature state","text":""},{"location":"features/timecapsule/#timecapsule","title":"Timecapsule","text":"<p>MVICore offers a <code>Timecapsule</code> interface you can use to save/restore the state of your <code>Feature</code>:</p> <pre><code>class SomeFeature(\n    // pass an instance in constructor:\n    timeCapsule: TimeCapsule&lt;Parcelable&gt;? = null\n    // ...\n) : ActorReducerFeature&lt;Wish, Effect, State, News&gt;(\n    // initial state depends on having something inside TimeCapsule,\n    // or falling back to default value:\n    initialState = timeCapsule?.get(SomeFeature::class.java) ?: State()\n    // ...\n) {\n    init {\n        // Register with the same key:\n        timeCapsule?.register(SomeFeature::class.java) { state }\n    }\n\n    @Parcelize\n    data class State(\n        val someField: Int = 0\n    ) : Parcelable\n\n    // ...\n}    \n</code></pre> <p>It's the responsibility of the actual <code>TimeCapsule</code> implementation to actually call the supplied lambda and grab the <code>state</code> when it needs to persist itself.</p>"},{"location":"features/timecapsule/#androidtimecapsule","title":"AndroidTimeCapsule","text":"<p>The <code>mvicore-android</code> module adds an implementation of the interface, <code>AndroidTimeCapsule</code>. You can create it with a <code>Bundle</code> and you call <code>saveState(outState: Bundle)</code> on it:</p> <pre><code>val savedInstanceState: Bundle = TODO() // get it from Android\nval timeCapsule = AndroidTimeCapsule(savedInstanceState)\nval feature = SomeFeature(timeCapsule) // restore\n\n// later:\nfun onSaveInstanceState(outState: Bundle) {\n    super.onSaveInstanceState(outState)\n    timeCapsule.saveState(outState) // save\n}\n</code></pre> <p><code>AndroidTimeCapsule</code> will make sure to persist the state of all <code>Features</code> registered to it.</p> <p>You are free to use the same instance of <code>AndroidTimeCapsule</code> to persist multiple <code>Features</code>, provided the keys they register with are unique (pay attention to this when persisting multiple instances of the same class!).</p>"},{"location":"features/timecapsule/#resetting-some-information","title":"Resetting some information","text":"<p>Consider this case:</p> <ol> <li>your <code>Feature</code> can do long running operations</li> <li>your <code>State</code> has an <code>isLoading</code> flag to reflect when the operation is running</li> <li>you show a loading spinner on the UI depending on the value of this flag</li> <li>after saving state to <code>Bundle</code>, your <code>Feature</code> is disposed, cancelling the operation</li> <li>after restoring state from <code>Bundle</code>, <code>isLoading</code> is restored with a value of <code>true</code>, rendering a loading spinner on the UI, even though there's no actual operation backing this visual information </li> </ol> <p>In such cases you can reflect cancelled operations with the state accessor lambda when registering in <code>TimeCapsule</code>:</p> <pre><code>class SomeFeature(\n    timeCapsule: TimeCapsule&lt;Parcelable&gt;? = null\n    // ... \n) : ActorReducerFeature&lt;Wish, Effect, State, News&gt;(\n    // ...\n    initialState = timeCapsule?.get(SomeFeature::class.java) ?: State()\n    // ...\n) {\n    init {\n        // Reset some fields to reflect cancelled operations:\n        timeCapsule?.register(SomeFeature::class.java) { state.copy(\n            isLoading = false\n        )}\n    }\n\n    @Parcelize\n    data class State(\n        val someField: Int = 0,\n        val isLoading: Boolean = false\n    ) : Parcelable\n\n    // ...\n}    \n</code></pre> <p>In the above example <code>someField</code> will be saved/restored with its actual value, while <code>isLoading</code> is always saved with value of <code>false</code>.</p> <p>Upon restoring the <code>Feature</code>, you can implement logic in <code>Bootstrapper</code> to decide if you need to restart a cancelled operation. Then, only when it's actually loading, your <code>isLoading</code> flag will be set to <code>true</code> again. This way, your UI always reflects the actual state of loading.</p>"},{"location":"middlewares/configuration/","title":"Middleware configurations","text":""},{"location":"middlewares/configuration/#what-is-a-middleware-configuration","title":"What is a Middleware configuration?","text":"<p>It is defined as a pair of a condition and a list of factories:</p> <pre><code>data class MiddlewareConfiguration(\n    private val condition: WrappingCondition,\n    private val factories: List&lt;ConsumerMiddlewareFactory&lt;*&gt;&gt;\n)\n</code></pre> <p>If the <code>WrappingCondition</code> returns <code>true</code>, all the <code>Middlewares</code> created by <code>factories</code> will be wrapped around the target.</p> <p>If it returns <code>false</code>, the original object is returned without any modifications.</p>"},{"location":"middlewares/configuration/#what-is-a-wrappingcondition","title":"What is a WrappingCondition?","text":"<p><code>WrappingCondition</code> is an interface with the sole responsibility of deciding whether any target should be wrapped or not:</p> <pre><code>interface WrappingCondition {\n\n    fun shouldWrap(target: Any, name: String?, standalone: Boolean) : Boolean\n}\n</code></pre> <p>The interface contains implementations for most common case checks, such as:</p> <pre><code>// Implementations checking the target      -- returns true if the target:\nWrappingCondition.IsNamed                   // ...has a name\nWrappingCondition.Name.SimpleMatcher        // ...has a name that contains a given substring\nWrappingCondition.Name.Regex                // ...has a name that matches a given regex\nWrappingCondition.InstanceOf                // ...is an instance of a given class / interface\nWrappingCondition.PackageName.SimpleMatcher // ...has a package name that contains a given substring\nWrappingCondition.PackageName.Regex         // ...has a package name that matches a given regex\nWrappingCondition.IsStandalone              // ...is standalone (not part of a binding)\n\n// Implementations checking a condition     -- returns true:\nWrappingCondition.Always                    // ...always\nWrappingCondition.Never                     // ...never\nWrappingCondition.Conditional               // ...if a given () -&gt; Boolean lambda returns true\n\n// Implementations delegating to others     -- returns true if:\nWrappingCondition.Not                       // the passed WrappingCondition returns false\nWrappingCondition.EitherOr                  // delegates to one of two given WrappingConditions based on a condition\nWrappingCondition.AnyOf                     // any of the passed WrappingConditions return true\nWrappingCondition.AllOf                     // all of the passed WrappingConditions return true\n</code></pre> <p>If the above is not enough for any reason, you can write your own implementation of the interface.</p>"},{"location":"middlewares/configuration/#what-is-a-consumermiddlewarefactory","title":"What is a ConsumerMiddlewareFactory?","text":"<p>Basically just a lambda to create a <code>Middleware</code> given a <code>Consumer&lt;T&gt;</code>:</p> <pre><code>typealias ConsumerMiddlewareFactory&lt;T&gt; = (Consumer&lt;T&gt;) -&gt; ConsumerMiddleware&lt;T&gt;\n\n// In practice:\nval middlewareFactory: ConsumerMiddlewareFactory&lt;*&gt; = { consumer -&gt; SomeMiddleware(consumer) }\n</code></pre>"},{"location":"middlewares/configuration/#ok-how-do-i-use-it","title":"Ok, how do I use it?","text":"<p>Let's say:</p> <ol> <li>You want to add <code>LoggingMiddleware</code> to all of your bindings and consumers</li> </ol> <p>and</p> <ol> <li>You only want to add <code>PlaybackMiddleware</code> to bindings and consumers if all of these hold true:<ul> <li>it's a debug build</li> <li>they are named</li> <li>they are in a certain package</li> <li>but they are definitely not an instance of some class</li> </ul> </li> </ol> <p>Here's how you would do it:</p> <pre><code>Middlewares.configurations.add(\n    MiddlewareConfiguration(\n        condition = WrappingCondition.Always,\n        factories = listOf(\n            { consumer -&gt; LoggingMiddleware(consumer, { Timber.d(it) }) }\n        )\n    )\n)\n\n\nMiddlewares.configurations.add(\n    MiddlewareConfiguration(\n        condition = WrappingCondition.AllOf(\n            WrappingCondition.Conditional { BuildConfig.DEBUG },\n            WrappingCondition.IsNamed,\n            WrappingCondition.PackageName.SimpleMatcher(\"com.example.package\"),\n            WrappingCondition.Not(\n                WrappingCondition.InstanceOf(SomeClass::class.java)\n            )\n        ),\n        factories = listOf(\n            { consumer -&gt; PlaybackMiddleware(consumer, recordStore, { Timber.d(it) }) }\n        )\n    )\n)\n</code></pre>"},{"location":"middlewares/configuration/#under-the-hood","title":"Under the hood","text":"<p>Whenever you call <code>.wrap</code> a <code>Consumer&lt;T&gt;</code> manually, or whenever the <code>Binder</code> does the same automatically, the extension function will apply your list of <code>MiddlewareConfiguration</code> objects:</p> <pre><code>fun &lt;T : Any&gt; Consumer&lt;T&gt;.wrap(\n    name: String? = null,\n    // remainder omitted\n): Consumer&lt;T&gt; {\n    // remainder omitted\n\n    Middlewares.configurations.forEach {\n        current = it.applyOn(current, target, name, standalone)\n    }\n\n    // remainder omitted\n\n    return current\n}\n</code></pre>"},{"location":"middlewares/loggingmiddleware/","title":"LoggingMiddleware","text":""},{"location":"middlewares/loggingmiddleware/#loggingmiddleware","title":"LoggingMiddleware","text":""},{"location":"middlewares/loggingmiddleware/#logging-out-of-the-box","title":"Logging - out of the box","text":"<p>MVICore comes with a configurable <code>LoggingMiddleware</code> that you can use right away.</p> <pre><code>val wrapped = LoggingMiddleware(consumer, { System.out.println(it) })\n</code></pre> <p>The actual logging part is not hardcoded, so you can set your preferred way of producing output.</p> <p>The constructor also accepts an optional <code>Configuration</code> object if you want to modify the templates it uses. Check the actual file for more details.</p>"},{"location":"middlewares/middleware/","title":"What is a middleware and why is it good for me?","text":""},{"location":"middlewares/middleware/#tldr","title":"TL;DR","text":"<p>You can extract the cross-cutting concerns of your app (like logging) and put them into <code>Middlewares</code> that can be used as generic plugins instead of copy-pasting the same solution over and over and polluting your code.</p>"},{"location":"middlewares/middleware/#the-big-picture","title":"The big picture","text":"<p>You can picture this like a wrapped input:</p> <ol> <li> <p>No middleware: <code>Source -&gt; Input</code></p> </li> <li> <p>Adding a layer of middleware: <code>Source -&gt; Middleware(Input)</code></p> </li> <li> <p>Adding n layers of middleware: <code>Source -&gt; Middleware(Middleware(...Middleware(Input)...))</code></p> </li> </ol> <p>Every layer of <code>Middleware</code> forwards its input to its wrapped inner core (whether its the actual <code>Input</code>, or just another layer of <code>Middleware</code>).</p> <p>Whether or not an <code>Input</code> is wrapped in <code>Middlewares</code> is unknown to the <code>Source</code>.</p>"},{"location":"middlewares/middleware/#the-base-idea","title":"The base idea","text":"<p>Consider the <code>Consumer&lt;T&gt;</code> interface:</p> <pre><code>package io.reactivex.functions;\n\n/**\n * A functional interface (callback) that accepts a single value.\n * @param &lt;T&gt; the value type\n */\npublic interface Consumer&lt;T&gt; {\n    /**\n     * Consume the given value.\n     * @param t the value\n     * @throws Exception on error\n     */\n    void accept(T t) throws Exception;\n}\n</code></pre> <p>We can easily create a wrapper layer around it:</p> <pre><code>abstract class Middleware&lt;T&gt;(\n    private val wrapped: Consumer&lt;T&gt;\n) : Consumer&lt;T&gt; {\n\n    override fun accept(t: T) {\n        // do whatever you want before passing it to wrapped...\n        wrapped.accept(t)\n        // ... or after it\n        // ... or even modify what's passed down to wrapped\n    }\n}\n</code></pre> <p>Let's play around with it and add some simple implementations:</p> <pre><code>class HelloMiddleware(\n    private val wrapped: Consumer&lt;String&gt;\n) : Middleware&lt;String&gt;(wrapped) {\n\n    override fun accept(t: String) {\n        wrapped.accept(\"Hello $t\")\n    }\n}\n\nclass ReverserMiddleware(\n    private val wrapped: Consumer&lt;String&gt;\n) : Middleware&lt;String&gt;(wrapped) {\n\n    override fun accept(t: String) {\n        wrapped.accept(t.reversed())\n    }\n}\n\nclass LoggingMiddleware&lt;T&gt;(\n    private val wrapped: Consumer&lt;T&gt;,\n    private val logger: (String) -&gt; Unit\n) : Middleware&lt;T&gt;(wrapped) {\n\n    override fun accept(t: T) {\n        logger.invoke(\"LoggingMiddleware: element - $t\")\n        wrapped.accept(t)\n    }\n}\n</code></pre> <p>Now we can compose them and take them for a test ride:</p> <pre><code>val target: Consumer&lt;String&gt; = TODO()\n\nval wrappedWithMiddlewares: Consumer&lt;String&gt; =\n    ReverserMiddleware(\n        HelloMiddleware(\n            LoggingMiddleware(\n                { System.out.println(it) },\n                target\n            )\n        )\n    )\n\nwrappedWithMiddlewares.accept(\"MVICore\")\n\n// Should output to console:\n// \"LoggingMiddleware: element - Hello erocIVM!\"\n</code></pre> <p>Explanation: the order in which an element is passing through the <code>Middleware</code> layers is from the outermost -&gt; inwards. In the above example this means that the passed in string:</p> <ol> <li>gets reversed</li> <li>gets decorated with Hello %s!</li> <li>gets logged</li> </ol>"},{"location":"middlewares/playbackmiddleware/","title":"PlaybackMiddleware - The engine of the Time Travel Debugger","text":""},{"location":"middlewares/playbackmiddleware/#time-travel-debugging-out-of-the-box","title":"Time Travel Debugging - out of the box","text":"<p>MVICore comes with a configurable <code>PlaybackMiddleware</code> that you can use right away.</p> <pre><code>val playbackMiddleware = PlaybackMiddleware(\n        wrapped = consumer,\n        recordStore = recordStore,\n        logger = { System.out.println(it) } // optional\n    )\n</code></pre> <p>The parameter <code>recordStore</code> should be an instance of <code>PlaybackMiddleware.RecordStore</code>.</p> <p>There's currently one implementation inside the library for that:</p> <pre><code>val recordStore = MemoryRecordStore(\n    playbackScheduler = AndroidSchedulers.mainThread(),\n    logger = { System.out.println() } // optional\n)\n</code></pre> <p>Since this is an in-memory implementation, it will not survive app crashes. This makes it somewhat limited, but for most cases it should be enough (when you have a crash, at least you have a stacktrace - the more difficult cases are when you don't, but still have to figure out what's going wrong). Implementations that record to a persistent storage / network are on the roadmap (contributions welcome).</p>"},{"location":"middlewares/playbackmiddleware/#how-to-use","title":"How to use","text":""},{"location":"middlewares/playbackmiddleware/#setup","title":"Setup","text":"<ol> <li>Create your <code>RecordStore</code> instance</li> <li>Create your <code>PlaybackMiddleware</code> factory, passing in your <code>RecordStore</code></li> <li>Add a rule when your middleware should be used as seen in Middleware configurations</li> <li>You can either call <code>.wrap()</code> on a <code>Consumer&lt;T&gt;</code> or let <code>Binder</code> do it automatically as seen in Automatic wrapping of reactive components with Middlewares</li> </ol>"},{"location":"middlewares/playbackmiddleware/#the-manual-way","title":"The manual way","text":"<p>Create a record manually:</p> <ol> <li>Holding on to your <code>RecordStore</code> instance (should be the same reference you passed to your <code>PlaybackMiddleware</code>), call <code>.startRecording()</code> on it. This will record all elements that pass through on any of the <code>Consumer&lt;T&gt;</code> instances wrapped <code>PlaybackMiddleware</code>.</li> <li>Call <code>.stopRecording()</code> when you are done.</li> </ol> <p>Replay a record manually:</p> <ol> <li>Get a list of recorded and available channels from your <code>RecordStore</code> by calling <code>fun records(): Observable&lt;List&lt;RecordKey&gt;&gt;</code> on it. This is an <code>Observable</code> as if any of the channels are disposed in the meantime, they are removed from the <code>RecordStore</code> to prevent memory leaks.</li> <li>Select a <code>RecordKey</code> from the list. You can use its <code>name</code> field to find the one you are looking for - it should contain the name of the wrapping you used when you called a <code>consumer.wrap(\"Name\")</code> or when you created a binding using `binder.bind(source to target named \"Name\")</li> <li>Call <code>playback(recordKey)</code> on <code>RecordStore</code>.</li> </ol>"},{"location":"middlewares/playbackmiddleware/#the-automatic-way","title":"The automatic way","text":"<p>If you are on Android and using DebugDrawer, you can find a UI control module you can add to it in the <code>mvicore-debugdrawer</code> dependency.</p> <p></p> <p>UI controls include:</p> <ul> <li>start recording</li> <li>stop recording</li> <li>start playback</li> <li>record selection dropdown, which automatically updates itself with all records available in the RecordStore</li> </ul>"},{"location":"middlewares/playbackmiddleware/#a-word-about-playback","title":"A word about playback","text":"<p>As said, <code>RecordStore</code> will record all channels, but can only play back one channel at a time, which you have to select (either with the UI controls, or with a <code>RecordKey</code> from code).</p> <p>This is by design. Imagine a case, where you have (A), (B), (C) components wired in a way that any element passed to (A) will trigger a chain reaction that trickles down all the way to UI.</p> <pre><code>// input --&gt; (A) --&gt; (B) --&gt; (C) --&gt; UI\n\nbinder.bind(input to A)\nbinder.bind(A to B)\nbinder.bind(B to C)\nbinder.bind(C to UI)\n</code></pre> <p>Let's assume we add <code>PlaybackMiddleware</code> on all the right ends of the arrows to record elements.</p> <p>If you play back elements to (A), it will trigger all inputs to (B), which in turn will trigger (C), which in turn will talk to the UI, as a result of the chain reaction.</p> <p>If you played back elements simultaneously on all channels:</p> <ul> <li>(A) would be fine receiving its own playback</li> <li>(B) would receive 2x elements: both from its own playback, and ones triggered from (A)'s playback</li> <li>(C) would receive 3x elements: elements from its own playback, elements triggered from (B)'s playback, and elements triggered from (A)'s playback that triggered new elements in (B)</li> <li>UI would receive 4x as many elements as intended</li> </ul> <p>Limiting playback to one channel is still enough for you to play detective when something goes wrong:</p> <ol> <li>Attach a runtime debugger, set a breakpoint, play back input channel for that component and check what's happening there.</li> <li>If the problem is not there, pick another component and play back elements to its input.</li> <li>Rinse and repeat.</li> </ol> <p>You might have cases where you are sure that you could replay multiple channels simultaneously that wouldn't affect each other (e.g. navigation events and view models rendered). Support for multi-channel playback in such cases will be added in later versions.</p>"},{"location":"middlewares/wrapping/","title":"Automatic wrapping of reactive components with Middlewares","text":""},{"location":"middlewares/wrapping/#the-power-of-consumert","title":"The power of <code>Consumer&lt;T&gt;</code>","text":"<p>Remember when in the Core concepts we said that <code>Feature</code> is a <code>Consumer</code> of <code>Wish</code> and an <code>ObservableSource</code> of <code>State</code>? And that in general, the framework is working with outputs of type <code>ObservableSource&lt;T&gt;</code> and inputs of type <code>Consumer&lt;T&gt;</code>?</p> <p>Now this comes really handy.</p> <p>There's a Kotlin extension method to wrap any <code>Consumer&lt;T : Any&gt;</code> object with <code>Middlewares</code>:</p> <pre><code>val target: Consumer&lt;T&gt; = TODO()\n\n// without name\ntarget.wrap()\n\n// or with name\ntarget.wrap(\"Target input\")\n</code></pre> <p>In essence, you can add <code>Middlewares</code> to just about anything you want if it implements <code>Consumer&lt;T&gt;</code>.</p>"},{"location":"middlewares/wrapping/#what-middlewares","title":"What Middlewares?","text":"<p>The list of <code>Middlewares</code> that will be applied can be customised flexibly by name, package name, and lots of other conditions (including your own) as we we'll see in the next chapter: 3. Middleware configurations</p>"},{"location":"middlewares/wrapping/#middlewares-for-features-out-of-the-box","title":"Middlewares for Features - out of the box","text":"<p>As an extra, the <code>BaseFeature</code> implementation is also using <code>Consumer&lt;T&gt;</code> internally for its components.</p> <p>That means, you can add <code>Middlewares</code> to not just the <code>Reducer</code>, but the <code>Actor</code>, <code>Bootstrapper</code>, <code>PostProcessor</code>, and <code>NewsPublisher</code> as well. These wrappings will be named:</p> <ul> <li>com.example.myapp.MyCoolFeature.BootstrapperImpl.output</li> <li>com.example.myapp.MyCoolFeature.ActorImpl.input</li> <li>com.example.myapp.MyCoolFeature.ReducerImpl.input</li> <li>com.example.myapp.MyCoolFeature.PostProcessorImpl.input</li> <li>com.example.myapp.MyCoolFeature.NewsPublisherImpl.input</li> </ul>"},{"location":"middlewares/wrapping/#middlewares-for-bindings-out-of-the-box","title":"Middlewares for bindings - out of the box","text":"<p>Whenever you create bindings, you get free <code>Middlewares</code>:</p> <pre><code>binder.bind(source to target)\nbinder.bind(source to target using transformer)\n</code></pre> <p>Since <code>target</code> here is always a <code>Consumer&lt;T&gt;</code>, <code>Binder</code> can automatically invoke <code>.wrap()</code> on it.</p> <p>These wrappings will have a name containing the connection name, the source and the target: <code>ANONYMOUS (SourceObject.toString() --&gt; TargetObject.toString()\")</code>.</p> <p>If you want descriptive names for the connection part instead of ANONYMOUS, remember that you can use your own:</p> <pre><code>binder.bind(source to target named \"MyTarget.ViewModels\")\nbinder.bind(source to target using transformer \"\"MyTarget.ViewModels\")\n</code></pre>"}]}